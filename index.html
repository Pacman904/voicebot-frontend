<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OpenAI VoiceBot</title>
  <style>
    body { font-family: Arial; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f8f9fa; }
    .container { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 30px rgba(0,0,0,0.15); width: 90%; max-width: 600px; height: 80%; display: flex; flex-direction: column; }
    .mic-btn { background: #28a745; border: none; border-radius: 50%; width: 100px; height: 100px; cursor: pointer; font-size: 24px; color: white; transition: background 0.3s; margin: auto 0 20px; }
    #statusLabel { text-align: center; margin-bottom: 30px; font-size: 24px; color: green; display: none; }
    #consoleLogs { flex: 1; padding: 15px; background: #212529; color: #cccccc; font-family: monospace; overflow-y: auto; white-space: pre-line; }
  </style>
</head>
<body>
  <div class="container">
    <div id="statusLabel">on Air</div>
    <div id="consoleLogs"></div>
    <button id="micButton" class="mic-btn" onclick="toggleConnection()"><i class="fas fa-microphone"></i></button>
    <audio id="openAIAudio" style="width: 100%; margin: 15px 0;" crossorigin="anonymous"></audio>
  </div>

  <script src="https://kit.fontawesome.com/845924f09c.js"></script>
  <script src="https://unpkg.com/parse/dist/parse.min.js"></script>
  <script>
    Parse.initialize("uNEbQKjymSX8qmK9gorQNRbSuaV23eMHriF2Yeoi", "NY08Fa7grB4I1AOOcrjKN2b9w6sWke5GCA8rpxBM");
    Parse.serverURL = "https://parseapi.back4app.com/";

    let peerConnection = null;
    let userStream = null;
    let dc = null;
    let audioContext = null;

    function logMessage(message) {
      document.getElementById('consoleLogs').textContent += `[${new Date().toISOString()}] ${message}\n`;
    }

    async function initializeWebRTC(iceServers) {
      const config = {
        iceServers: iceServers || [
          { urls: "stun:stun.relay.metered.ca:80" },
          { urls: "turn:global.relay.metered.ca:80", username: "dabe0db86808a99aa36c7309", credential: "n7sdOC9KUqBloUJ4" },
          { urls: "turn:global.relay.metered.ca:80?transport=tcp", username: "dabe0db86808a99aa36c7309", credential: "n7sdOC9KUqBloUJ4" },
          { urls: "turn:global.relay.metered.ca:443", username: "dabe0db86808a99aa36c7309", credential: "n7sdOC9KUqBloUJ4" },
          { urls: "turns:global.relay.metered.ca:443?transport=tcp", username: "dabe0db86808a99aa36c7309", credential: "n7sdOC9KUqBloUJ4" }
        ],
        iceTransportPolicy: "relay"
      };

      peerConnection = new RTCPeerConnection(config);
      peerConnection.ontrack = e => document.getElementById('openAIAudio').srcObject = e.streams[0];
      
      dc = peerConnection.createDataChannel("control");
      dc.onopen = () => logMessage("Datenkanal geÃ¶ffnet");
      dc.onmessage = e => logMessage(`OpenAI: ${e.data}`);

      return peerConnection;
    }

    async function startConnection() {
      try {
        userStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const response = await Parse.Cloud.run("createEphemeralSession", { model: "gpt-4o-realtime-preview", voice: "verse" });
        
        peerConnection = await initializeWebRTC(response.iceServers);
        userStream.getTracks().forEach(track => peerConnection.addTrack(track));
        
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        await Parse.Cloud.run("sendSignalingData", { sessionId: response.sessionId, data: { type: "offer", sdp: offer.sdp } });
        const answer = await Parse.Cloud.run("forwardToOpenAI", { 
          openaiSessionId: response.openaiSessionId,
          clientSecret: response.clientSecret,
          sdp: offer.sdp 
        });

        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer.sdp));
        logMessage("Verbindung erfolgreich");
        updateUIConnectionState('connected');
      } catch (error) {
        logMessage(`Fehler: ${error.message}`);
      }
    }

    async function toggleConnection() {
      if (peerConnection?.connectionState === 'connected') await stopConnection();
      else await startConnection();
    }

    async function stopConnection() {
      if (peerConnection) peerConnection.close();
      if (userStream) userStream.getTracks().forEach(track => track.stop());
      if (audioContext) audioContext.close();
      updateUIConnectionState('disconnected');
      logMessage("Verbindung getrennt");
    }

    function updateUIConnectionState(state) {
      document.getElementById('micButton').style.backgroundColor = state === 'connected' ? '#dc3545' : '#28a745';
      document.getElementById('statusLabel').style.display = state === 'connected' ? 'block' : 'none';
    }
  </script>
</body>
</html>
